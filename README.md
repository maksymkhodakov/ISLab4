# Ходаков Максим ТТП-42 
## Лабораторна робота №4 з дисципліни "Інтелектуальні системи"


## Приклад використання CSP в задачі розміщення N ферзей

------

# Рев’ю коду

Це рев’ю стосується коду, який реалізує задачу CSP (Constraint Satisfaction Problem) для гри N-Ферзів із використанням пошуку з поверненням. Код також містить реалізацію евристик та відстеження вартості шляху. Нижче наведено аналіз основних компонентів, ефективності алгоритму та рекомендації для покращення.

## 1. Загальна структура

Код добре структурований і складається з кількох ключових частин:
- Клас `CSP`, який реалізує загальний алгоритм CSP з використанням пошуку з поверненням.
- Функція обмежень, що визначає, чи атакують ферзі один одного.
- Основний блок, який ініціалізує змінні, домени та виконує розв'язання задачі.

Рішення читається легко, а використання евристик додає ефективності алгоритму.

---

## 2. Оцінка основних компонентів

### Алгоритм CSP

Алгоритм реалізує стандартний підхід до розв'язання задачі CSP із пошуком у глибину (пошук з поверненням). Код відповідає вимогам:
- Використовує порожнє присвоєння як початковий стан.
- На кожному кроці вибирає змінну, присвоює їй значення та перевіряє на узгодженість.
- Виконує перевірку мети (чи всім змінним присвоєно значення).
- Відстежує вартість шляху (кількість кроків).

Це дозволяє правильно та ефективно розв’язувати задачу.

### Евристики

У коді реалізовано три евристики:
1. **MRV (мінімальна кількість решти значень):**
   - Вибирає змінну, домен якої має найменшу кількість можливих значень. Це зменшує кількість потенційних гілок у дереві пошуку.

2. **Ступенева евристика:**
   - Якщо декілька змінних мають однаковий мінімальний розмір домену, вибирається змінна з найбільшим ступенем (найбільшою кількістю обмежень із сусідніми змінними). Це сприяє зменшенню конфліктів.

3. **Евристика найменш обмежувального значення:**
   - Серед усіх можливих значень для змінної вибирається значення, яке спричиняє найменшу кількість конфліктів для інших змінних.

Ці евристики суттєво покращують продуктивність, зменшуючи кількість необхідних повернень.

### Відстеження вартості шляху

Код відстежує вартість шляху, яка збільшується на кожному кроці при присвоєнні значення змінній. Це корисно для оцінки ефективності алгоритму, особливо при тестуванні на більших розмірах дошки.

---

## 3. Ефективність та продуктивність

Код демонструє хорошу ефективність для стандартних задач (наприклад, N=8). Використання евристик суттєво зменшує кількість рекурсивних викликів і прискорює пошук рішення. 

Проте для більших значень N може бути корисним впровадження додаткових оптимізацій, таких як:
- Проріджування доменів (Forward Checking), щоб виключати несумісні значення одразу після кожного присвоєння.
- Використання алгоритму підтримки узгодженості дуг (AC-3), щоб підтримувати узгодженість між змінними під час виконання алгоритму.

---

## 4. Рекомендації щодо покращення

1. **Оптимізація обчислень:**
   - Реалізувати кешування підрахунків під час використання евристики найменш обмежувального значення.
   - У ступеневій евристиці враховувати реальні обмеження між змінними, а не лише загальну кількість неприсвоєних змінних.

2. **Додаткові оптимізації:**
   - Впровадити проріджування доменів, щоб зменшити кількість конфліктів ще до рекурсивних викликів.
   - Додати перевірку узгодженості дуг для забезпечення узгодженості між усіма змінними.

3. **Покращення структури коду:**
   - Додати коментарі для складних частин коду.
   - Розділити функціональність на менші модулі або функції для кращої читабельності.

4. **Тестування на більших значеннях N:**
   - Перевірити продуктивність алгоритму для більших значень N (наприклад, N=16 чи N=20).
   - Визначити, які частини алгоритму потребують оптимізації.

---

## 5. Висновок

Код реалізує всі основні аспекти CSP, включаючи вибір змінних, призначення значень, перевірку узгодженості та пошук рішення. Використання евристик забезпечує ефективність, а відстеження вартості шляху дозволяє аналізувати продуктивність алгоритму.

Застосування рекомендованих оптимізацій може покращити продуктивність для великих задач і зробити код ще більш гнучким та ефективним.

------


# Приклад використання CSP в задачі створення розкладу

У цій роботі розглядається застосування **CSP (Constraint Satisfaction Problem)** для вирішення задачі створення розкладу занять. Використовуються різні алгоритми та евристики, такі як пошук з поверненням, MRV, LCV та поширення обмежень, для підвищення ефективності розв'язку.

## Зміст

1. [Вступ](#вступ)
2. [Основні компоненти](#основні-компоненти)
   - [Дані](#дані)
   - [Моделі](#моделі)
3. [Ініціалізація CSP](#ініціалізація-csp)
4. [Алгоритми та евристики](#алгоритми-та-евристики)
   - [Базовий алгоритм пошуку з поверненням](#базовий-алгоритм-пошуку-з-поверненням)
   - [Евристика MRV (Minimum Remaining Values)](#евристика-mrv-minimum-remaining-values)
   - [Евристика LCV (Least Constraining Value)](#евристика-lcv-least-constraining-value)
   - [Поширення обмежень](#поширення-обмежень)
5. [Реалізація](#реалізація)
   - [Файл `data.py`](#файл-datapy)
   - [Файл `model.py`](#файл-modelpy)
   - [Файл `csp_initializer.py`](#файл-csp_initializerpy)
   - [Файл `csp.py`](#файл-csppy)
   - [Файл `mrv.py`](#файл-mrvpy)
   - [Файл `lcv.py`](#файл-lcvpy)
   - [Файл `constraint_propagation.py`](#файл-constraint_propagationpy)
   - [Файл `main.py`](#файл-mainpy)
6. [Висновки](#висновки)
7. [Посилання](#посилання)

## Вступ

**Задача розкладу занять** є класичним прикладом проблеми задоволення обмежень (CSP), де необхідно призначити ресурси (аудиторії, викладачі) подіям (заняттям) в певні часові інтервали, дотримуючись різних обмежень.

У цій роботі використовується CSP для автоматизованого створення розкладу занять університету. Розглядаються різні алгоритми та евристики для ефективного вирішення цієї задачі.

## Основні компоненти

### Дані

Дані для задачі розкладу зберігаються у файлі `datasource.py`. Вони включають:

```python
DAYS = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"]

MEETING_TIMES = [
    "08:40 - 10:15",
    "10:35 - 12:10",
    "12:20 - 13:55",
    "14:05 - 15:40"
]

AUDITORIUMS = [
    ["1", 20],
    ["2", 35],
    # ...
]

TEACHERS = [
    {"name": "Will Turner", "subject": "Algorithms"},
    # ...
]

SUBJECTS = [
    {"name": "Algorithms", "number_of_students": 60, "groups": 3, "teacher": "Will Turner"},
    # ...
]

SPECIALITIES = [
    {"name": "122", "subjects": ["Algorithms", "Algebra", "C++", "AI", "IT"]},
    # ...
]
```

### Моделі

У файлі `model.py` визначені основні класи:

```python
class Event:
    def __init__(self, speciality, subject, room, time, day, type_of_class):
        self._speciality = speciality
        self._subject = subject
        # ...

class Teacher:
    def __init__(self, name, subject):
        self._name = name
        self._subject = subject

class Subject:
    def __init__(self, name, number_of_students, groups, teacher):
        self._name = name
        # ...
```

## Ініціалізація CSP

Файл `csp_initializer.py` відповідає за ініціалізацію CSP. Основні функції:

- **Ініціалізація змінних та доменів**:
```python
my_csp = {
    VARIABLES: classes,
    DOMAINS: meeting_times,
    CONSTRAINTS: [same_teacher, same_spec, groups_conflict]
}
```

- **Перевірка обмежень**:
```python
def same_teacher(assignment):
    ...

def same_spec(assignment):
    ...

def groups_conflict(assignment):
    ...
```

## Алгоритми та евристики

### Базовий алгоритм пошуку з поверненням

Реалізований у файлі `csp.py`:

```python
def backtracking(assignment, csp, heuristic):
    ...
```

### Евристика MRV (Minimum Remaining Values)

Реалізована у файлі `mrv.py`:

```python
def find_mrv(assignment, csp):
    ...
```

### Евристика LCV (Least Constraining Value)

Реалізована у файлі `lcv.py`:

```python
def lcv_heuristic(assignment):
     ...
```

### Поширення обмежень

Реалізовано у файлі `constraint_propagation.py`:

```python
def constraint_propagation(assignment, csp):
     ...
```

## Реалізація

### Файл `data.py`

Ініціалізація даних для CSP.

### Файл `model.py`

Реалізація класів `Event`, `Teacher`, `Subject`, `Room`, `Speciality`.

### Файл `csp_initializer.py`

Ініціалізація змінних, доменів та обмежень.

### Файл `csp.py`

Базовий алгоритм пошуку.

### Файл `mrv.py`

Реалізація евристики MRV.

### Файл `lcv.py`

Реалізація евристики LCV.

### Файл `constraint_propagation.py`

Реалізація алгоритму поширення обмежень.

### Файл `main.py`

Основна точка входу, запуск алгоритмів та вивід результатів.

## Висновки

У цій роботі продемонстровано застосування CSP для вирішення задачі створення розкладу занять.

## Посилання

- [Constraint Satisfaction Problems](https://en.wikipedia.org/wiki/Constraint_satisfaction_problem)
- [Backtracking Algorithm](https://en.wikipedia.org/wiki/Backtracking)
- [Minimum Remaining Values (MRV)](https://www.geeksforgeeks.org/minimum-remaining-value-mrv-and-degree-heuristic-in-backtracking/)
- [Least Constraining Value (LCV)](https://www.geeksforgeeks.org/least-constraining-value-heuristic-in-backtracking/)
- [Constraint Propagation](https://en.wikipedia.org/wiki/Constraint_propagation)

